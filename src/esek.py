import echunk
import schunk
from ssek import Ssek
FRONT = __import__('direction').Direction.FRONT
BACK = __import__('direction').Direction.BACK
CAPACITY = __import__('echunk').CAPACITY

# Transform ssek into esek
def ssek_to_esek(s):
    version = s.version_max + 1
    front = schunk.echunk_of_schunk(s.front, version)
    back  = schunk.echunk_of_schunk(s.back,  version)
    middle = s.middle
    return Esek.create(front, middle, back, version)

# Transform esek into ssek
def esek_to_ssek(e):
    front = schunk.schunk_of_echunk(e.front)
    back  = schunk.schunk_of_echunk(e.back)
    middle = e.middle
    version_max = e.version
    # TODO: it is also possible to change the spec and call e.invalidate()
    e.empty()
    return Ssek.create(front, middle, back, version_max)


# class Esek:
#   front: echunk containing first elements
#   back: echunk containing last elements
#   middle: ssek - recursive structure
#   version: integer used to keep track of ownership

class Esek:

    # ------------------------------------------------------------------------ #
    # Constructors

    # Constructor - used internally by create and create_empty functions
    def __init__(self, front, middle, back, version):
        self.front = front
        self.middle = middle
        self.back = back
        self.version = version
        
    # Class method - creates & returns empty esek
    @classmethod
    def create_empty(cls, version = 0):
        front = echunk.Echunk(version)
        back = echunk.Echunk(version)
        middle = Ssek.create_empty()
        return cls(front, middle, back, version)

    # Class method - creates & returns esek using given arguments
    @classmethod
    def create(cls, front, middle, back, version = 0):
        front = front
        middle = middle
        back = back
        return cls(front, middle, back, version)

    # Initialize esek with values generated by given function
    @classmethod
    def init(cls, size, fun):
        result = cls.create_empty()
        for i in range(size):
            result.push_back(fun(i))
        return result


    # ------------------------------------------------------------------------ #
    # Basic utility functions 

    def is_empty(self):
        return self.front.is_empty() and self.back.is_empty()

    # Get size of esek
    def size(self):
        return self.size_aux(0, 1)

    def size_aux(self, total, level):
        total += self.front.deep_size(level)
        total += self.back.deep_size(level)
        total = self.middle.size_aux(total, level + 1)
        return total


    # ------------------------------------------------------------------------ #
    # Push & pop elements

    def push(self, pov, item):
        this, that = self.get_both(pov)
        if this.is_full():
            if that.is_empty():
                assert self.middle.is_empty()
                self.set_both(pov, that, this)
            else:
                sthis = schunk.schunk_of_echunk(this)
                self.middle = self.middle.push(pov, sthis, self.version)
                self.set_this(pov, echunk.Echunk())
        this = self.get_this(pov)
        this.push(pov, item)

    def pop(self, pov):
        assert not self.is_empty()
        this, that = self.get_both(pov)
        if this.is_empty():
            assert self.middle.is_empty()
            x = that.pop(pov)
        else:
            x = this.pop(pov)
            self.populate(pov)
        return x

    def push_front(self, item):
        self.push(FRONT, item)

    def push_back(self, item):
        self.push(BACK, item)

    def pop_front(self):
        return self.pop(FRONT)

    def pop_back(self):
        return self.pop(BACK)


    # ------------------------------------------------------------------------ #
    # Operations on esek

    # Reverses order of elements
    def rev(self):
        # reverse front & back
        self.front.rev()
        self.back.rev()
        # swap front and back
        tmp = self.front
        self.front = self.back
        self.back = tmp
        # recursive reverse
        self.middle = self.middle.rev()

    # Swap data with another esek
    def swap(self, s2):
        s1 = self
        # save s1 to tmp
        s1_front  = s1.front 
        s1_middle = s1.middle
        s1_back   = s1.back
        # move from s2 to s1
        s1.front  = s2.front
        s1.middle = s2.middle
        s1.back   = s2.back
        # move from tmp to s2
        s2.front  = s1_front
        s2.middle = s1_middle
        s2.back   = s1_back

    # Iterate over seq and apply function
    def iter(self, pov, fun):
        this, that = self.get_both(pov)
        this.iter(pov, fun)
        self.middle.iter(pov, lambda c: c.iter(pov ^ this.dir, fun))
        that.iter(pov, fun)

    # Empty an esek
    # TODO: je crois que le nom à utiliser c'est "clear", cf
    # https://pythontic.com/containers/deque/clear
    def empty(self):
        self.version = 0
        self.front   = echunk.Echunk()
        self.back    = echunk.Echunk()
        self.middle  = Ssek.create_empty()

    # Invalidate esek
    def invalidate(self):
        self.version = 0
        s2.front = None
        s2.middle = None
        s2.back = None


    # ------------------------------------------------------------------------ #
    # Printing

    # Print esek
    def print_general(self, print_item):
        def print_fun(item):
            print_item(item)
            print(", ", end="")
        print("[", end="")
        self.iter(FRONT, print_fun)
        if self.is_empty():
            print("]")
        else:
            print("\b\b]")

    # Print in debugging mode, show content of each field
    def print_debug(self, print_item, indent):
        def print_fun(item):
            print_item(item)
            print(" ", end="")
        print(" " * indent, end="")
        self.front.print_general(print_fun)
        if not self.middle.is_empty():
            self.middle.print_debug(lambda c: c.iter(FRONT, print_fun),indent+2)
        else:
            print(".")
        print(" " * indent, end="")
        self.back.print_general(print_fun)


    # ------------------------------------------------------------------------ #
    # Access elements

    # Override [] operator
    def __getitem__(self, i):
        return self.get(i)

    # Get item at index i
    def get(self, i):
        assert not self.is_empty()
        return self.get_aux(i, 1)

    # Auxiliary function for get
    def get_aux(self, i, level):
        front_size = self.front.deep_size(level) 
        middle_size = self.middle.size_aux(0, level+1)
        # if it's in the front we get it from there
        if i < front_size:
            return self.front.get_deep(i, level, FRONT)
        # if it's in the back we get it from there
        elif i >= front_size + middle_size:
            new_index = i - front_size - middle_size
            return self.back.get_deep(new_index, level, FRONT)
        # else we calculate index in middle and we look there
        else:
            new_index = i - front_size
            return self.middle.get_aux(new_index, level + 1)


    # ------------------------------------------------------------------------ #
    # Auxiliary methods

    # Access front/back elements depending on pov
    def get_this(self, pov):
        if (pov == FRONT):
            return self.front
        elif (pov == BACK):
            return self.back

    def get_both(self, pov):
        if (pov == FRONT):
            return self.front, self.back
        elif (pov == BACK):
            return self.back, self.front

    # Set front/back elements depending on pov
    def set_this(self, pov, this):
        if (pov == FRONT):
            self.front = this
        elif (pov == BACK):
            self.back = this

    def set_both(self, pov, this, that):
        if (pov == FRONT):
            self.front = this
            self.back = that
        elif (pov == BACK):
            self.front = that
            self.back = this
    
    # Place elements from middle into front and back to respect invariant
    def populate(self, pov):
        this = self.get_this(pov)
        if this.is_empty() and not self.middle.is_empty():
            self.middle, this = self.middle.pop(pov, self.version)
            self.set_this(pov, schunk.echunk_of_schunk(this, self.version))

    def populate_sides(self):
        self.populate(FRONT)
        self.populate(BACK)

    # Peek elements on the extremities of the esek (front/back)
    def peek(self, pov):
        assert not self.is_empty()
        this, that = self.get_both(pov)
        if this.is_empty():
            assert self.middle.is_empty()
            return that.peek(pov)
        else:
            return this.peek(pov)

    def peek_back(self):
        return self.peek(BACK)

    def peek_front(self):
        return self.peek(FRONT)


    # ------------------------------------------------------------------------ #
    # Concatenation

    # Puts data from s2 to the back of current object, and clears s2
    def concat_back(self, s2):
        s1 = self
        if (s2.is_empty()):
            return
        if (s1.is_empty()):
            s1.swap(s2)
            return

        m1 = s1.middle
        m2 = s2.middle

        # push data to the outside to simplify small cases
        if s1.front.is_empty():
            assert m1.is_empty()
            b = s1.back
            s1.back = s1.front
            s1.front = b
        if s2.back.is_empty():
            assert m2.is_empty()
            f = s2.front
            s2.front = s2.back
            s2.back = f

        # push s1.back and s2.front into s1.middle
        m1 = m1.push_back_concat(schunk.schunk_of_echunk(s1.back))
        m1 = m1.push_back_concat(schunk.schunk_of_echunk(s2.front))

        # TODO: j'ai changé l'ordre du elif ci-dessous
        if m1.is_empty():
            # if m1 is empty then m2 is the new middle
            new_middle = m2
        elif m2.is_empty():
            # if m2 is empty then m1 is the new middle
            new_middle = m1
        else:
            # else concatenate m1 and m2, compacting two adjacent chunks into one if possible
            if m1.peek_back().size() + m2.peek_front().size() <= CAPACITY:
                m2, p = m2.pop_front()
                m1 = m1.push_back_concat(p)
            new_middle = m1.concat_back(m2)
       
        # place new_middle in s1.middle and s2.back into s1.back
        s1.middle = new_middle
        s1.back = s2.back
        # restore the invariant
        s1.populate_sides()
        # TODO NOTE: it is also possible to change the specification and call invalidate
        s2.empty()
        # TODO: pour s1.version, il faut prendre le max des version de s1 et de s2.
